"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2404],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),m=l(n),c=r,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||o;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p[m]="string"==typeof e?e:r,i[1]=p;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},90747:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>p,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={id:"useImport",title:"useImport"},i=void 0,p={unversionedId:"api-reference/antd/hooks/import/useImport",id:"api-reference/antd/hooks/import/useImport",title:"useImport",description:"useImport hook allows you to handle your CSV import logic easily. It gives you the properties to pass to Ant Design's ` and  components and handles the upload logic. It uses papaparse under the hood to parse CSV` files.",source:"@site/docs/api-reference/antd/hooks/import/useImport.md",sourceDirName:"api-reference/antd/hooks/import",slug:"/api-reference/antd/hooks/import/useImport",permalink:"/docs/api-reference/antd/hooks/import/useImport",draft:!1,editUrl:"https://github.com/refinedev/refine/tree/master/documentation/docs/api-reference/antd/hooks/import/useImport.md",tags:[],version:"current",lastUpdatedBy:"Daniel Monettelli",lastUpdatedAt:1671163008,formattedLastUpdatedAt:"Dec 16, 2022",frontMatter:{id:"useImport",title:"useImport"},sidebar:"someSidebar",previous:{title:"useStepsForm",permalink:"/docs/api-reference/antd/hooks/form/useStepsForm"},next:{title:"useSimpleList",permalink:"/docs/api-reference/antd/hooks/list/useSimpleList"}},s={},l=[{value:"Usage",id:"usage",level:2},{value:"With <code>&lt;ImportButton&gt;</code> (Recommended)",id:"with-importbutton-recommended",level:3},{value:"With Ant Design&#39;s <code>&lt;Upload&gt;</code> and <code>&lt;Button&gt;</code> Components",id:"with-ant-designs-upload-and-button-components",level:3},{value:"Handling Relational Data",id:"handling-relational-data",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"Properties",id:"properties",level:3},{value:"Return Values",id:"return-values",level:3},{value:"Type Parameters",id:"type-parameters",level:3}],d=(m="PropsTable",function(e){return console.warn("Component "+m+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var m;const u={toc:l};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"useImport")," hook allows you to handle your ",(0,r.kt)("inlineCode",{parentName:"p"},"CSV")," import logic easily. It gives you the properties to pass to Ant Design's ",(0,r.kt)("a",{parentName:"p",href:"https://ant.design/components/upload/"},(0,r.kt)("inlineCode",{parentName:"a"},"<Upload>"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://ant.design/components/button/"},(0,r.kt)("inlineCode",{parentName:"a"},"<Button>"))," components and handles the upload logic. It uses ",(0,r.kt)("a",{parentName:"p",href:"https://www.papaparse.com/docs"},(0,r.kt)("inlineCode",{parentName:"a"},"papaparse"))," under the hood to parse ",(0,r.kt)("inlineCode",{parentName:"p"},"CSV")," files. "),(0,r.kt)("p",null,"It's return type is compatible with ",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/antd/components/buttons/import-button"},(0,r.kt)("inlineCode",{parentName:"a"},"<ImportButton>")),". It can also be further customized by using it with Ant Design's ",(0,r.kt)("a",{parentName:"p",href:"https://ant.design/components/upload/"},(0,r.kt)("inlineCode",{parentName:"a"},"<Upload>")),"\xa0and ",(0,r.kt)("a",{parentName:"p",href:"https://ant.design/components/button/"},(0,r.kt)("inlineCode",{parentName:"a"},"<Button>"))," props."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { useImport } from "@pankod/refine-antd";\n\nconst { uploadProps, buttonProps, mutationResult } = useImport(options);\n')),(0,r.kt)("h2",{id:"usage"},"Usage"),(0,r.kt)("p",null,"Assume we have a ",(0,r.kt)("inlineCode",{parentName:"p"},"CSV")," file of this contents:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csv",metastring:'title="dummy.csv"',title:'"dummy.csv"'},'"title","categoryId"\n"dummy title 1","3"\n"dummy title 2","44"\n')),(0,r.kt)("p",null,"This file should be parsed as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'[\n    {\n        title: "dummy title 1",\n        categoryId: "3",\n    },\n    {\n        title: "dummy title 2",\n        categoryId: "44",\n    }\n]\n')),(0,r.kt)("h3",{id:"with-importbutton-recommended"},"With ",(0,r.kt)("inlineCode",{parentName:"h3"},"<ImportButton>")," (Recommended)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import {\n    List,\n    Table,\n    useTable,\n// highlight-start\n    useImport,\n    ImportButton,\n// highlight-end\n} from "@pankod/refine-antd";\n\nexport const PostList: React.FC = () => {\n    const { tableProps } = useTable<IPost>();\n\n// highlight-next-line\n    const importProps = useImport<IPostFile>();\n\n    return (\n        <List\n            pageHeaderProps={{\n// highlight-next-line\n                extra: <ImportButton {...importProps} />,\n            }}\n        >\n            <Table {...tableProps} rowKey="id">\n                <Table.Column dataIndex="id" title="ID" />\n                <Table.Column dataIndex="title" title="Title" />\n                <Table.Column dataIndex="status" title="Status" />\n            </Table>\n        </List>\n    );\n};\n\ninterface IPostFile {\n    title: string;\n    categoryId: string;\n}\n\ninterface IPost {\n    id: number;\n    title: string;\n    status: string;\n}\n')),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/antd/components/buttons/import-button"},(0,r.kt)("inlineCode",{parentName:"a"},"<ImportButton"))," accepts two properties: ",(0,r.kt)("inlineCode",{parentName:"p"},"buttonProps")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"uploadProps"),". It just wraps ",(0,r.kt)("a",{parentName:"p",href:"https://ant.design/components/button/"},(0,r.kt)("inlineCode",{parentName:"a"},"<Button>"))," component with the ",(0,r.kt)("a",{parentName:"p",href:"https://ant.design/components/upload/"},(0,r.kt)("inlineCode",{parentName:"a"},"<Upload>\b"))," component to reduce some boilerplate code."),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"with-ant-designs-upload-and-button-components"},"With Ant Design's ",(0,r.kt)("inlineCode",{parentName:"h3"},"<Upload>")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"<Button>")," Components"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import {\n    List,\n    Table,\n    useTable,\n// highlight-start\n    useImport,\n    Button,\n    Icons,\n    Upload,\n// highlight-end\n} from "@pankod/refine-antd";\n\nconst { ImportOutlined } = Icons;\n\nexport const PostList: React.FC = () => {\n    const { tableProps } = useTable<IPost>();\n\n// highlight-next-line\n    const { buttonProps, uploadProps } = useImport<IPostFile>();\n\n    return (\n        <List\n// highlight-start\n            pageHeaderProps={{\n                extra: (\n                    <Upload {...uploadProps}>\n                        <Button icon={<ImportOutlined />} {...buttonProps}>\n                            Import\n                        </Button>\n                    </Upload>\n                ),\n            }}\n// highlight-end\n        >\n            <Table {...tableProps} rowKey="id">\n                <Table.Column dataIndex="id" title="ID" />\n                <Table.Column dataIndex="title" title="Title" />\n            </Table>\n        </List>\n    );\n};\n')),(0,r.kt)("p",null,"This usage is open to further customizations of Ant Design's ",(0,r.kt)("a",{parentName:"p",href:"https://ant.design/components/button/"},(0,r.kt)("inlineCode",{parentName:"a"},"<Button>"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://ant.design/components/upload/"},(0,r.kt)("inlineCode",{parentName:"a"},"<Upload>"))," components."),(0,r.kt)("br",null),(0,r.kt)("p",null,"In both examples, when user clicks the import buttons and selects a ",(0,r.kt)("inlineCode",{parentName:"p"},"CSV")," file, ",(0,r.kt)("inlineCode",{parentName:"p"},"useImport")," parses the content with ",(0,r.kt)("a",{parentName:"p",href:"https://www.papaparse.com/docs"},"papaparse"),", creates the resources one by one or as batches (depending on the configuration). Which endpoint to create the given resource is inferred from the current route."),(0,r.kt)("p",null,"Resources are added one by one (",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/hooks/data/useCreate"},(0,r.kt)("inlineCode",{parentName:"a"},"useCreate")),") or as batches (",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/hooks/data/useCreateMany"},(0,r.kt)("inlineCode",{parentName:"a"},"useCreateMany")),") if explicitly configured with ",(0,r.kt)("a",{parentName:"p",href:"#useimport-options"},(0,r.kt)("inlineCode",{parentName:"a"},"batchSize"))," option. By default, ",(0,r.kt)("inlineCode",{parentName:"p"},"batchSize")," is 1."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"If ",(0,r.kt)("inlineCode",{parentName:"p"},"batchSize")," is more than 1, ",(0,r.kt)("inlineCode",{parentName:"p"},"createMany")," method should be implemented in ",(0,r.kt)("inlineCode",{parentName:"p"},"DataProvider"),".",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"/docs/api-reference/core/providers/data-provider"},"Refer to DataProvider documentation for further information about importing the default css. ","\u2192"))),(0,r.kt)("br",null),(0,r.kt)("h3",{id:"handling-relational-data"},"Handling Relational Data"),(0,r.kt)("p",null,"In some cases, you might want to change/process the data of ",(0,r.kt)("inlineCode",{parentName:"p"},"CSV")," file after parsing. Example cases of this requirement: your data contains relational data and references to data in other places, your backend API requires your data to be sent in a specific format. You can further customize ",(0,r.kt)("inlineCode",{parentName:"p"},"useImport")," to achieve this."),(0,r.kt)("p",null,"Assume this is the ",(0,r.kt)("inlineCode",{parentName:"p"},"CSV")," file we want to create resources from:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csv",metastring:'title="dummy.csv"',title:'"dummy.csv"'},'"title","content","status","categoryId","userId"\n"dummy title 1","dummy content 1","rejected","3","8"\n"dummy title 2","dummy content 2","draft","44","8"\n"dummy title 3","cummy content 3","published","41","10"\n')),(0,r.kt)("p",null,"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"user")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"category")," are relational fields, we shouldn't store them as objects. Instead, we should keep only their ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," fields in our exported files. And ",(0,r.kt)("inlineCode",{parentName:"p"},"CSV")," format doesn't support JSON data, we stored ",(0,r.kt)("inlineCode",{parentName:"p"},"category.id")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"categoryId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"user.id")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"userId"),"."),(0,r.kt)("p",null,"When creating these resources back, we should map it back to our backend API's required format. ",(0,r.kt)("inlineCode",{parentName:"p"},"mapData")," option allows us to do this. Here is an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const importProps = useImport<IPostFile>({\n    mapData: (item) => {\n        return {\n            title: item.title,\n            content: item.content,\n            status: item.status,\n            category: {\n                id: item.categoryId,\n            },\n            user: {\n                id: item.userId,\n            },\n        };\n    },\n});\n\ninterface IPostFile {\n    title: string;\n    status: string;\n    content: string;\n    categoryId: string;\n    userId: number;\n}\n")),(0,r.kt)("p",null,"Now, parsed data is mapped to conform our APIs requirements."),(0,r.kt)("h2",{id:"api-reference"},"API Reference"),(0,r.kt)("h3",{id:"properties"},"Properties"),(0,r.kt)(d,{module:"@pankod/refine-antd/useImport",mdxType:"PropsTable"}),(0,r.kt)("h3",{id:"return-values"},"Return Values"),(0,r.kt)("h3",{id:"type-parameters"},"Type Parameters"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Property"),(0,r.kt)("th",{parentName:"tr",align:null},"Desription"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TItem"),(0,r.kt)("td",{parentName:"tr",align:null},"Interface of parsed csv data"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"any"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TData"),(0,r.kt)("td",{parentName:"tr",align:null},"Result type of the data query type that extends ",(0,r.kt)("a",{parentName:"td",href:"/docs/api-reference/core/interfaceReferences#baserecord"},(0,r.kt)("inlineCode",{parentName:"a"},"BaseRecord"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/api-reference/core/interfaceReferences#baserecord"},(0,r.kt)("inlineCode",{parentName:"a"},"BaseRecord")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TError"),(0,r.kt)("td",{parentName:"tr",align:null},"Custom error object that extends ",(0,r.kt)("a",{parentName:"td",href:"/docs/api-reference/core/interfaceReferences#httperror"},(0,r.kt)("inlineCode",{parentName:"a"},"HttpError"))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"/docs/api-reference/core/interfaceReferences#httperror"},(0,r.kt)("inlineCode",{parentName:"a"},"HttpError")))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TVariables"),(0,r.kt)("td",{parentName:"tr",align:null},"Values for mutation function"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"any"))))))}c.isMDXComponent=!0}}]);